#pragma once

#include "../Math/Source/Vector3.h"
#include "../Math/Source/Vector4.h"

struct D3DXPLANE;
class Matrix;
class Quaternion;

class Plane
{
public:

	///////////////////////////////////////////////////////////////////////////
	///	생성자 / 복사 , 이동

	explicit Plane(float a = 0.0f, float b = 0.0f, float c = 0.0f, float d = 0.0f) noexcept;
	explicit Plane(const Vector3& normal, float d) noexcept;
	explicit Plane(const Vector4& value) noexcept;

	///////////////////////////////////////////////////////////////////////////////
	//@(left_top)
	//l
	//(up vector)
	//l
	//@(center)----(right vector)---@(right_bottom)
	//Normal(a,b,c) = Forward Vector (화면 안쪽으로 들어가는 방향)
	///////////////////////////////////////////////////////////////////////////////
	explicit Plane(const Vector3& point_center, const Vector3& point_left_top, const Vector3& point_right_bottom) noexcept;

	Plane(const Plane& other) noexcept;
	Plane(Plane&& other) noexcept;
	///////////////////////////////////////////////////////////////////////////

	inline float& operator[](unsigned int index) noexcept
	{
		return m[index];
	}


	inline Plane operator =(const Plane& other) noexcept
	{
		memcpy(this, &other, sizeof(other));
		return *this;
	}

	inline bool operator ==(const Plane& other) const noexcept
	{
		return ((a == other.a) && (b == other.b) && (c == other.c) && (d == other.d));
	}

	inline bool operator !=(const Plane& other) const noexcept
	{
		return ((a != other.a) || (b != other.b) || (c != other.c) || (d != other.d));
	}

	//	변환
	operator float*() const noexcept;

	//	연산자

	///////////////////////////////////////////////////////////////////////////////
	//	플레인의 값들을 String으로 변환합니다.
	///////////////////////////////////////////////////////////////////////////////
	std::string ToString();

	///////////////////////////////////////////////////////////////////////////////
	//	플레인의 값들을 Wstring으로 변환합니다.
	///////////////////////////////////////////////////////////////////////////////
	std::wstring ToStringW();

	///////////////////////////////////////////////////////////////////////////////
	//	Plane을 D3DXPLANE 으로 변환합니다.
	///////////////////////////////////////////////////////////////////////////////
	D3DXPLANE ToD3DXPLANE();


	///////////////////////////////////////////////////////////////////////////////
	//	플레인을 정규화합니다.
	///////////////////////////////////////////////////////////////////////////////
	const Plane& Normalize();

	///////////////////////////////////////////////////////////////////////////////
	//	Plane에 Vector4를 내적시킵니다.
	///////////////////////////////////////////////////////////////////////////////
	float Dot(const Vector4& value);

	///////////////////////////////////////////////////////////////////////////////
	//	Plane에 Vector3(위치) 를 내적시킵니다. ( 결과값 d || d > 0 : Plane의 앞 | d < 0 : Plane의 뒤 | d == 0 : Plane과 겹침 )
	///////////////////////////////////////////////////////////////////////////////
	float DotCoordinate(const Vector3& value);

	///////////////////////////////////////////////////////////////////////////////
	//	Plane에 Vector3(방향) 을 내적시킵니다. (일반 Vector3 내적과 같습니다.)
	///////////////////////////////////////////////////////////////////////////////
	float DotNormal(const Vector3& value);


	///////////////////////////////////////////////////////////////////////////////
	//	플레인을 정규화합니다.
	///////////////////////////////////////////////////////////////////////////////
	static Plane Normalize(const Plane& value);
	
	///////////////////////////////////////////////////////////////////////////////
	//	매트릭스로 플레인을 변환시킵니다.
	///////////////////////////////////////////////////////////////////////////////
	static Plane Transform(const Plane& plane, const Matrix& matrix);
	
	///////////////////////////////////////////////////////////////////////////////
	//	쿼터니언으로 플레인을 변환시킵니다.
	///////////////////////////////////////////////////////////////////////////////
	static Plane Transform(const Plane& plane, const Quaternion& rotation);

public:


	///////////////////////////////////////////////////////////////////////////
	///	X , Y , Z , W
	union
	{
		float m[4];
		Vector4 vector4;

		struct
		{
			union
			{
				Vector3 normal;

				struct
				{
					float a, b, c;
				};
			};

			float d;
		};
	};
	///////////////////////////////////////////////////////////////////////////

};